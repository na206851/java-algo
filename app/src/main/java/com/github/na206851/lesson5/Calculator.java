package com.github.na206851.lesson5;import com.github.na206851.lesson3.DynamicArray;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class Calculator {    public static void main(String[] args) {        Calculator test = new Calculator();        // System.out.println(strToPolyshNotation("(-2) + 2"));        System.out.println(test.evalRPN(new String[]{"2", "2", "+"}));    }   //сделать так чтобы evan to RPN принимал список токенов и проводил только вычисления    // принцип singly responsibility    //дробим задачи    //нужен метод который парсить строку чтобы можно было передавать строку в любом виде (убирал пробелы , правильно работал с унарными операторами)    public int postfixCalculator(String expression) {        return evalRPN(infixToPolishNotation(parseString(expression)));    }    public List<String> parseString(String string) {        string = string.replaceAll(" ", "");        List<String> result = new DynamicArray<>();        StringBuilder acc = new StringBuilder();        int index = 0;        if (string.charAt(0) == '-' || isNums((string.charAt(0)))) {            acc.append(string.charAt(0));            index = 1;        }        for (int i = index; i < string.toCharArray().length; i++) {            if (isNums(string.charAt(i))) {                acc.append(string.charAt(i));            } else if (isOperator(string.charAt(i)) && string.charAt(i) == '(') {                result.add(String.valueOf(string.charAt(i)));            } else if (isOperator(string.charAt(i)) && string.charAt(i) == ')') {                if (isOperator(string.charAt(i)) && !acc.isEmpty()) {                    result.add(acc.toString());                    acc.setLength(0);                }                result.add(String.valueOf(string.charAt(i)));            } else if (isOperator(string.charAt(i - 1)) && string.charAt(i) == '-') {                acc.append(string.charAt(i));            } else if (isOperator(string.charAt(i)) && currentOperation(String.valueOf(string.charAt(i))) == 3) {                if (!acc.isEmpty()) {                    result.add(acc.toString());                    acc.setLength(0);                }                result.add(String.valueOf(string.charAt(i)));            } else if (isOperator(string.charAt(i)) && currentOperation(String.valueOf(string.charAt(i))) == 2) {                if (!acc.isEmpty()) {                    result.add(acc.toString());                    acc.setLength(0);                }                result.add(String.valueOf(string.charAt(i)));            }        }        if (!acc.isEmpty()) {            result.add(acc.toString());            acc.setLength(0);        }        return result;    }    public List<String> infixToPolishNotation(List<String> infixExpression) {        MyStack<String> stack = new MyStack<>();        List<String> result = new DynamicArray<>();        int priority;        for (int i = 0; i < infixExpression.size(); i++) {            priority = currentOperation(infixExpression.get(i));            if (priority == 0) {                result.add(infixExpression.get(i));            } else if (priority == 1) {                stack.push(infixExpression.get(i));            } else if (priority == 2) {                stack.push(infixExpression.get(i));            } else if (priority == 3) {                stack.push(infixExpression.get(i));            } else if (priority == -1) {                while (!stack.isEmpty()) {                    if (stack.peek().equals("(")) {                        stack.pop();                    } else {                        result.add(stack.pop());                    }                }            }        }        while (!stack.isEmpty()) {            if (stack.peek().equals("(") || stack.peek().equals(")")) {                stack.pop();            } else {                result.add(stack.pop());            }        }        return result;    }    public int evalRPN(List<String> rpnExpression) {        MyStack<Integer> stack = new MyStack<>();        for (String i : rpnExpression) {            if (isNums(i)) {                stack.push(Integer.parseInt(i));            } else {                int tmp1 = stack.pop();                int tmp2 = stack.pop();                int result = 0;                switch (i) {                    case "+":                        result = tmp1 + tmp2;                        break;                    case "-":                        result = tmp2 - tmp1;                        break;                    case "*":                        result = tmp1 * tmp2;                        break;                    case "/":                        result = tmp2 / tmp1;                        break;                    default:                        stack.pop();                }                stack.push(result);            }        }        return stack.pop();    }    private boolean isNums(String str) {        try {            Integer.parseInt(str);            return true;        } catch (NumberFormatException ex) {            return false;        }    }    private boolean isNums(char i) {        try {            Integer.parseInt(String.valueOf(i));            return true;        } catch (NumberFormatException ex) {            return false;        }    }    private boolean isOperator(char i) {        return i == '(' || i == ')' || i == '-' || i == '+' || i == '*' || i == '/';    }    private static int currentOperation(String i) {        if (i.equals("*") || i.equals("/")) {            return 3;        } else if (i.equals("+") || i.equals("-")) {            return 2;        } else if (i.equals("(")) {            return 1;        } else if (i.equals(")")) {            return -1;        } else {            return 0;        }    }}