package com.github.na206851.lesson5;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class Calculator {    public static void main(String[] args) {        Calculator test = new Calculator();        // System.out.println(strToPolyshNotation("(-2) + 2"));        System.out.println(test.evalRPN(new String[]{"2", "2", "+"}));    }   //сделать так чтобы evan to RPN принимал список токенов и проводил только вычисления    // принцип singly responsibility    //дробим задачи    //нужен метод который парсить строку чтобы можно было передавать строку в любом виде (убирал пробелы , правильно работал с унарными операторами)    private boolean isOperator(char i) {        return i == '(' || i == ')' || i == '-' || i == '+' || i == '*' || i == '/';    }    public List<String> modStr(String string) {        string = string.replaceAll(" ", "");        List<String> list = new ArrayList<>();        char[] arr = string.toCharArray();        StringBuilder result = new StringBuilder();        int index = 0;        if (string.charAt(0) == '-' || isNums(String.valueOf(string.charAt(0)))) {            result.append(string.charAt(0));            index = 1;        }        for (int i = index; i < arr.length; i++) {            char c = arr[i];            if (currentOperation(String.valueOf(c)) == 0) {                result.append(c);            } else if (currentOperation(String.valueOf(c)) == 2 || currentOperation(String.valueOf(c)) == 3) {                if (currentOperation(String.valueOf(arr[i - 1])) == 1 && currentOperation(String.valueOf(c)) == 2) {                    result.append(" " + c);                } else {                    result.append(" " + c + " ");                }            } else if (currentOperation(String.valueOf(c)) == 1) {                result.append(c + " ");            } else if (currentOperation(String.valueOf(c)) == -1) {                result.append(" " + c);            }        }        int count = 0;        for (String i : result.toString().split(" ")) {            if (i.equals("")) {                count++;            } else {                list.add(i);            }        }        return list;    }    public List<String> infixToPolishNotation(List<String> infixExpression) {        //todo переделать на лист чтобы метод закидыва результаты сразу в лист и использовал стрингбилдер как черпало        StringBuilder tokens = new StringBuilder();        Stack<String> stack = new Stack<>();        List<String> list = new ArrayList<>();        int priority;        int count = 0;        for (int i = 0; i < infixExpression.size(); i++) {            priority = currentOperation(infixExpression.get(i));            if (priority == 0) {                tokens.append(" ");                tokens.append(infixExpression.get(i));                tokens.append(" ");                list.add(infixExpression.get(i));                // переписать                count++;            } else if (priority == 1) {                stack.push(infixExpression.get(i));            } else if (priority == 2) {                stack.push(infixExpression.get(i));            } else if (priority == 3) {                stack.push(infixExpression.get(i));            } else if (priority == -1) {                while (!stack.isEmpty()) {                    if (stack.peek().equals("(")) {                        stack.pop();                    } else {                        if (stack.size() > 1) {                            tokens.append(stack.pop());                            tokens.append(" ");                        } else {                            tokens.append(stack.pop());                        }                    }                }            }        }        while (!stack.isEmpty()) {            if (stack.peek().equals("(") || stack.peek().equals(")")) {                stack.pop();            } else {                if (stack.size() > 1) {                    tokens.append(stack.pop());                    tokens.append(" ");                } else {                    tokens.append(stack.pop());                }            }        }        String[] arr = tokens.toString().split(" ");        List<String> list2 = new ArrayList<>();        for (String i : arr) {            if (i.equals("")) {                count++;            } else {                list2.add(i);            }        }        return list2;    }    private static int currentOperation(String i) {        if (i.equals("*") || i.equals("/")) {            return 3;        } else if (i.equals("+") || i.equals("-")) {            return 2;        } else if (i.equals("(")) {            return 1;        } else if (i.equals(")")) {            return -1;        } else {            return 0;        }    }    public int evalRPN(List<String> rpnExpression) {        //написать метод который принимает строку и возвращает интовое значение        Stack<Integer> stack = new Stack<>();        for (String i : rpnExpression) {            if (isNums(i)) {                stack.push(Integer.parseInt(i));            } else {                if (stack.size() == 1) {                    return stack.pop() * (-1);//                    break;                } else {                    int tmp1 = stack.pop();                    int tmp2 = stack.pop();                    int result = 0;                    switch (i) {                        case "+":                            result = tmp1 + tmp2;                            break;                        case "-":                            result = tmp2 - tmp1;                            break;                        case "*":                            result = tmp1 * tmp2;                            break;                        case "/":                            result = tmp2 / tmp1;                            break;                        default:                            stack.pop();                    }                    stack.push(result);                }            }        }        return stack.pop();    }    private boolean isNums(String str) {        try {            Integer.parseInt(str);            return true;        } catch (NumberFormatException ex) {            return false;        }    }    private boolean isNums(char i) {        try {            Integer.parseInt(String.valueOf(i));            return true;        } catch (NumberFormatException ex) {            return false;        }    }    private boolean isOperator(char i) {        return i == '(' || i == ')' || i == '-' || i == '+' || i == '*' || i == '/';    }    private static int currentOperation(String i) {        if (i.equals("*") || i.equals("/")) {            return 3;        } else if (i.equals("+") || i.equals("-")) {            return 2;        } else if (i.equals("(")) {            return 1;        } else if (i.equals(")")) {            return -1;        } else {            return 0;        }    }}