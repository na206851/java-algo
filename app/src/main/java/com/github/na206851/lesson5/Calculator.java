package com.github.na206851.lesson5;import com.sun.security.jgss.GSSUtil;import java.util.*;public class Calculator {    public static void main(String[] args) {        Calculator test = new Calculator();        // System.out.println(strToPolyshNotation("(-2) + 2"));        System.out.println(test.evalRPN(new String[]{"2", "2", "+"}));    }   //сделать так чтобы evan to RPN принимал список токенов и проводил только вычисления    // принцип singly responsibility    //дробим задачи    //нужен метод который парсить строку чтобы можно было передавать строку в любом виде (убирал пробелы , правильно работал с унарными операторами)    public List<String> modStr(String string) {     //метод работает парсить строку правильно        List<String> list = new ArrayList<>();        char[] arr = string.toCharArray();        StringBuilder result = new StringBuilder();        int index = 0;        if (string.charAt(0) == '-' || isNums(String.valueOf(string.charAt(0)))) {            result.append(string.charAt(0));            index = 1;        }        for (int i = index; i < string.toCharArray().length; i++) {            if (currentOperation(String.valueOf(arr[i])) == 0) {                result.append(arr[i]);            } else if (currentOperation(String.valueOf(arr[i])) == 2 || currentOperation(String.valueOf(arr[i])) == 3) {                if (currentOperation(String.valueOf(arr[i - 1])) == 1 && currentOperation(String.valueOf(arr[i])) == 2) {                    result.append(" " + arr[i]);                } else {                    result.append(" " + arr[i] + " ");                }            } else if (currentOperation(String.valueOf(arr[i])) == 1) {                result.append(arr[i] + " ");            } else if (currentOperation(String.valueOf(arr[i])) == -1) {                result.append(" " + arr[i]);            }        }        System.out.println(stringBuilder);        return null;//        StringBuilder result = new StringBuilder();////        List<String> arr = List.of(string.split(" "));////        for (String i : arr) {//            System.out.println(i+ " i ");//            if (i.equals("(")) {////                result.append(" (");//////            } else if (i.equals(")")) {//                result.append(" ) ");//            } else if (currentOperation(i) > -1) {//                result.append(i+" ");//            } else {//                result.append(" " + i);////            }//        }//        System.out.println(result + " result mod string");//        return result.toString();        int count = 0;        for (String i : result.toString().split(" ")) {            if (i.equals("")) {                count++;            } else {                list.add(i);            }        }        return list;    }    public static List<String> strToPolyshNotation(List<String> infixExpression) { // change in paramtr on String[] ( String [])        //метод должен принимать спиосок строк        // отдельно парсим строку и передаем ее в этот метод        // отдельно парсим , отдельно считаем значение выражения//        str = modStr(str);//        System.out.println(str+ " look input parametr in method strToPoolyshNotation");        String tokens = new String();        String[] arr = new String[]{};        Stack<String> stack = new Stack<>();        int priority;        for (int i = 0; i < arr.length; i++) {            priority = currentOperation(arr[i]);            if (priority == 0) {//лишний пробел появляется в этом месте                tokens += arr[i];            } else if (priority == 1) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == 2) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == 3) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == -1) {                while (!stack.isEmpty()) {                    if (stack.peek().equals("(")) {                        stack.pop();                    } else {                        tokens += " " + stack.pop();                    }                }            }        }        while (!stack.isEmpty()) {            if (stack.peek().equals("(") || stack.peek().equals(")")) {                stack.pop();            } else {                if (stack.size() > 1) {                    tokens.append(stack.pop());                    tokens.append(" ");                } else {                    tokens.append(stack.pop());                }            }        }        String[] arr = tokens.toString().split(" ");        List<String> list = new ArrayList<>();        for (String i : arr) {            if (i.equals("")) {                count++;            } else {                list.add(i);            }        }        return list;    }    private static int currentOperation(String i) {        if (i.equals("*") || i.equals("/")) {            return 3;        } else if (i.equals("+") || i.equals("-")) {            return 2;        } else if (i.equals("(")) {            return 1;        } else if (i.equals(")")) {            return -1;        } else {            return 0;        }    }    public int evalRPN(List<String> tmp) {        Stack<Integer> stack = new Stack<>();        for (String i : tmp) {            if (isNums(i)) {                stack.push(Integer.parseInt(i));            } else {                if (stack.size() == 1) {//нужно подумать про унарные операции                    return stack.pop() * (-1);//                    break;                } else {                    int tmp1 = stack.pop();                    int tmp2 = stack.pop();                    int result = 0;                    switch (i) {                        case "+":                            result = tmp1 + tmp2;                            break;                        case "-":                            result = tmp2 - tmp1;                            break;                        case "*":                            result = tmp1 * tmp2;                            break;                        case "/":                            result = tmp2 / tmp1;                            break;                        default:                            stack.pop();                    }                    stack.push(result);                }            }        }        return stack.pop();    }    private boolean isNums(String str) {        try {            Integer.parseInt(str);            return true;        } catch (NumberFormatException ex) {            return false;        }    }}