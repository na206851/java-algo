package com.github.na206851.lesson5;import com.sun.security.jgss.GSSUtil;import java.sql.SQLOutput;import java.util.*;public class Calculator {    public static void main(String[] args) {        Calculator test = new Calculator();        // System.out.println(strToPolyshNotation("(-2) + 2"));        System.out.println(test.evalRPN(new String[]{"2", "2", "+"}));    }   //сделать так чтобы evan to RPN принимал список токенов и проводил только вычисления    // принцип singly responsibility    //дробим задачи    //нужен метод который парсить строку чтобы можно было передавать строку в любом виде (убирал пробелы , правильно работал с унарными операторами)    public static String modStr(String string) {        List<String> modString = new ArrayList<>();        StringBuilder stringBuilder = new StringBuilder();        for (char i : string.toCharArray()) {            int priority = currentOperation(String.valueOf(i));            if (priority == 0) {                stringBuilder.append(i + " ");            } else if (priority == 1) {                stringBuilder.append("( ");            } else if (priority == -1) {                stringBuilder.append(" )");            } else if (priority == 2 || priority == 3) {                stringBuilder.append(i);            }        }        System.out.println(stringBuilder);        return null;//        StringBuilder result = new StringBuilder();////        List<String> arr = List.of(string.split(" "));////        for (String i : arr) {//            System.out.println(i+ " i ");//            if (i.equals("(")) {////                result.append(" (");//////            } else if (i.equals(")")) {//                result.append(" ) ");//            } else if (currentOperation(i) > -1) {//                result.append(i+" ");//            } else {//                result.append(" " + i);////            }//        }//        System.out.println(result + " result mod string");//        return result.toString();    }    public static List<String> strToPolyshNotation(List<String> infixExpression) { // change in paramtr on String[] ( String [])        //метод должен принимать спиосок строк        // отдельно парсим строку и передаем ее в этот метод        // отдельно парсим , отдельно считаем значение выражения//        str = modStr(str);//        System.out.println(str+ " look input parametr in method strToPoolyshNotation");        String tokens = new String();        String[] arr = new String[]{};        Stack<String> stack = new Stack<>();        int priority;        for (int i = 0; i < arr.length; i++) {            priority = currentOperation(arr[i]);            if (priority == 0) {//лишний пробел появляется в этом месте                tokens += arr[i];            } else if (priority == 1) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == 2) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == 3) {                stack.push(arr[i]);//                tokens += " ";            } else if (priority == -1) {                while (!stack.isEmpty()) {                    if (stack.peek().equals("(")) {                        stack.pop();                    } else {                        tokens += " " + stack.pop();                    }                }            }        }        while (!stack.isEmpty()) {            if (stack.peek().equals("(") || stack.peek().equals(")")) { //проверка оказалась нужной                stack.pop();            } else {                tokens += " " + stack.pop();            }        }        StringBuilder tmp = new StringBuilder(tokens);        System.out.println(tokens + " tokens");//        return tmp.toString().split(" ");        return List.of();    }    public static int currentOperation(String i) {        if (i.equals("*") || i.equals("/")) {            return 3;        } else if (i.equals("+") || i.equals("-")) {            return 2;        } else if (i.equals("(")) {            return 1;        } else if (i.equals(")")) {            return -1;        } else {            return 0;        }    }    public int evalRPN(String[] tmp) {//        String[] arr = new String[]{Arrays.toString(strToPolyshNotation(tmp).split(" "))};        System.out.println(Arrays.toString(tmp) + " смотрим на входной параметр в методе евал");        Stack<Integer> stack = new Stack<>();        for (String i : tmp) {//            System.out.println(i+ "смотрим по чему иттерируемся ");//            if (i.equals(" ")) {//                break;//            }            if (isNums(i)) {                stack.push(Integer.parseInt(i));            } else {                if (stack.size() == 1) {                    return stack.pop() * (-1);//                    break;                } else {                    int tmp1 = stack.pop();                    int tmp2 = stack.pop();                    int result = 0;                    switch (i) {                        case "+":                            result = tmp1 + tmp2;                            break;                        case "-":                            result = tmp2 - tmp1;                            break;                        case "*":                            result = tmp1 * tmp2;                            break;                        case "/":                            result = tmp2 / tmp1;                            break;                        default:                            stack.pop();                    }                    stack.push(result);                }            }        }        return stack.pop();    }    private boolean isNums(String str) {        try {            Integer.parseInt(str);            return true;        } catch (NumberFormatException ex) {            return false;        }    }}